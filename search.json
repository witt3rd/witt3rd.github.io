[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "witt3rd.github.io",
    "section": "",
    "text": "DSPy Tutorial\n\n\n\n\n\n\ncode\n\n\ntutorial\n\n\n\n\n\n\n\n\n\nMay 7, 2024\n\n\nDonald Thompson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Various technology explorations."
  },
  {
    "objectID": "posts/dspy/index.html",
    "href": "posts/dspy/index.html",
    "title": "DSPy Tutorial",
    "section": "",
    "text": "Here is a simple footnote1.\nA footnote can also have multiple lines2.\nDSPy is a new framework for developing applications using large language models (LLMs) that aims to solve the fragility and complexity issues of traditional LLM-based pipelines. It aims to make building complex, multi-step LLM applications more straightforward and robust by providing a declarative programming model and automated optimization capabilities.\nHere are some insightful questions to ask about DSPy to better understand its purpose, functionality, and usage:\nThese questions help in uncovering both the technical underpinnings and practical applications of DSPy, providing a comprehensive understanding of its value proposition and operational mechanics."
  },
  {
    "objectID": "posts/dspy/index.html#purpose-and-benefits",
    "href": "posts/dspy/index.html#purpose-and-benefits",
    "title": "DSPy Tutorial",
    "section": "Purpose and Benefits",
    "text": "Purpose and Benefits\n\nWhat specific challenges in using large language models does DSPy aim to overcome?\nDSPy aims to address the following key challenges in using large language models:\n\nFragility and complexity of traditional LLM-based pipelines34[^4]:\n\nDSPy provides a declarative, composable, and Pythonic syntax for building LLM-based programs, replacing the need for manual prompt engineering56[^4].\nDSPy includes an “automatic compiler” that can optimize the prompts, instructions, and LM weights for each component of an LLM program, improving the overall quality and efficiency78[^4].\n\nSpecialization and alignment issues:\n\nDSPy allows chaining together multiple LLM calls into a program, where the output of one LLM call becomes the input to the next[^3].\nDSPy introduces abstractions like “Signatures” to cleanly represent the input/output specifications of each LLM component9.\n\nHallucination problems:\n\nDSPy enables providing structured data (e.g. tables) as input to LLMs to constrain their outputs and avoid hallucinations10.\n\n\nIn summary, DSPy aims to make building complex, multi-step LLM applications more straightforward and robust by providing a declarative programming model and automated optimization capabilities to address the key challenges of fragility, specialization, alignment, and hallucination1112[^3][^4].\nCitations: 13:  https://www.youtube.com/watch?v=1QWXhEzlgME 14:  https://towardsdatascience.com/intro-to-dspy-goodbye-prompting-hello-programming-4ca1c6ce3eb9 [^3]:  https://arxiv.org/pdf/2310.03714.pdf [^4]:  https://www.theaidream.com/post/dspy-a-revolutionary-framework-for-programming-llms [^5]:  https://weaviate.io/blog/dspy-optimizers\n\n\nHow does DSPy improve the robustness and reliability of LLM-based applications compared to existing frameworks?\nDSPy improves the robustness and reliability of LLM-based applications compared to existing frameworks in several key ways:\n\nDeclarative programming model: DSPy provides a declarative, composable, and Pythonic syntax for building LLM-based programs, replacing the need for manual prompt engineering1516[^4]. This makes the application logic more explicit and easier to reason about.\nAutomated prompt optimization: DSPy includes an “automatic compiler” that can optimize the prompts, instructions, and LM weights for each component of an LLM program, improving the overall quality and efficiency1718[^4]. This eliminates the need for constant manual prompt tuning.\nModular architecture: DSPy allows chaining together multiple LLM calls into a program, where the output of one LLM call becomes the input to the next[^3]. This modular approach makes the application more robust to changes in individual components.\nStructured input/output: DSPy introduces abstractions like “Signatures” to cleanly represent the input/output specifications of each LLM component19. This helps avoid mismatches between components and makes the application more reliable.\nFlexibility and control: By providing a programming model, DSPy gives developers more flexibility and control over how the LLM components interact with each other[^3]. This allows for more sophisticated and reliable application logic.\n\nIn summary, by shifting the focus from prompting to programming, DSPy makes LLM-based applications more robust, reliable, and adaptable compared to existing frameworks that rely more heavily on manual prompt engineering2021[^3][^4].\nCitations: 22:  https://ai.plainenglish.io/unlocking-self-optimizing-llm-apps-harnessing-dspy-and-self-discover-fa05c7c818ad?gi=eee8647e4331 23:  https://www.theaidream.com/post/dspy-a-revolutionary-framework-for-programming-llms [^3]:  https://www.youtube.com/watch?v=41EfOY0Ldkc [^4]:  https://towardsdatascience.com/intro-to-dspy-goodbye-prompting-hello-programming-4ca1c6ce3eb9 [^5]:  https://github.com/stanfordnlp/dspy\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate some random data\ntheta = np.linspace(0, 2*np.pi, 100)\nr = np.random.rand(100)\n\n# Create a polar plot\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\n\n# Set the title and show the plot\nax.set_title('Line Plot on Polar Axis')\nplt.show()"
  },
  {
    "objectID": "posts/dspy/index.html#footnotes",
    "href": "posts/dspy/index.html#footnotes",
    "title": "DSPy Tutorial",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎\nMy reference.↩︎\nTo add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line.↩︎"
  }
]